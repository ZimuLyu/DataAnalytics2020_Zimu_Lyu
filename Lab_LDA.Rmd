---
title: "Lab_LDA"
author: "Zimu Lyu"
output: html_document
---

# lda in class

```{r}
library(MASS)
library(ISLR)

help(lda)

data("Smarket")
attach(Smarket)
head(Smarket)
str(Smarket)
# "Lag1" ~ "Lag5" : the percentage returns for each of the five previous trading days.
# "Volume" : the number of shares traded on the previous day, in billions of dollars.
# "Today" : the percentage return on the date.
# "Direction" : whether the market was Up or Down on this date.
```

```{r}
# train: 2001~2004
train <- (Year < 2005)
# test: 2005
Smarket.2005 = Smarket[!train,]
dim(Smarket.2005)
Direction.2005 <- Direction[!train]
```

```{r}
lda.fit <- lda(Direction ~ Lag1 + Lag2, data = Smarket, subset = train)
lda.fit
```

```{r}
lda.pred <- predict(lda.fit, Smarket.2005)
names(lda.pred)
lda.class <- lda.pred$class
table(lda.class, Direction.2005)
mean(lda.class == Direction.2005)
```

# lda 1

```{r}
library(kknn)
library(MASS)

data(ionosphere)
i2 <- ionosphere[,-1]
i2 <- i2[,-1]

ifit <- lda(class ~ ., data=i2, na.action="na.omit", CV=TRUE)
summary(ifit)
```

```{r}
ctable <- table(i2$class, ifit$class)
diag(prop.table(ctable, 1))
sum(diag(prop.table(ctable))) # total percent correct
```

# loess 1

```{r}
cars <- datasets::cars
cars.lo <- loess(dist ~ speed, cars)
predict(cars.lo, data.frame(speed = seq(5, 30, 1)), se = TRUE)
```

```{r}
cars.lo2 <- loess(dist ~ speed, cars, control = loess.control(surface = "direct")) # allow extrapolation
predict(cars.lo2, data.frame(speed = seq(5, 30, 1)), se = TRUE)
```

# loess 2

```{r}
library(graphics)
plot(cars, main = "lowess(cars)")
lines(lowess(cars), col = 2)
lines(lowess(cars, f = .2), col = 3)
legend(5, 120, c(paste("f = ", c("2/3", ".2"))), lty = 1, col = 2:3)
```

# loess 3

```{r}
with(cars, {
    plot(speed, dist)
    lines(supsmu(speed, dist))
    lines(supsmu(speed, dist, bass = 7), lty = 2)
    })
```

```{r}
# and
# http://archive.ics.uci.edu/ml/datasets/Student+Performance
# http://archive.ics.uci.edu/ml/datasets/NoisyOffice
# http://archive.ics.uci.edu/ml/datasets/Bike+Sharing+Dataset
```

# splines 1

```{r}
attach(cars)
plot(speed, dist, main = "data(cars)  &  smoothing splines")
```

```{r}
cars.spl <- smooth.spline(speed, dist)
(cars.spl)
```

```{r}
plot(cars.spl)
lines(cars.spl, col = "blue")
```

```{r}
plot(smooth.spline(speed, dist, df = 10))
lines(smooth.spline(speed, dist, df = 10), lty = 2, col = "red")
legend(5,120,
       c(paste("default [C.V.] => df =",round(cars.spl$df,1)),"s( * , df = 10)"), 
       col = c("blue","red"), lty = 1:2, bg = 'bisque')
```

```{r}
# residual plot
detach()
plot(residuals(cars.spl) ~ fitted(cars.spl))
abline(h = 0, col = "gray")
```

```{r}
# consistency check
stopifnot(all.equal(cars$dist, fitted(cars.spl) + residuals(cars.spl)))

# visualization
nKnots <- Vectorize(.nknots.smspl)
c.. <- adjustcolor("gray20",.5)
curve(nKnots, 1, 250, n=250)
abline(0,1, lty=2, col=c..)
text(90,90,"y = x", col=c.., adj=-.25)
abline(h=100,lty=2)
abline(v=200, lty=2)
```

```{r}
n <- c(1:799, seq(800, 3490, by=10), seq(3500, 10000, by = 50))
plot(n, nKnots(n), type="l", main = "Vectorize(.nknots.smspl) (n)")
abline(0,1, lty=2, col=c..); text(180,180,"y = x", col=c..)
n0 <- c(50, 200, 800, 3200); c0 <- adjustcolor("blue3", .5)
lines(n0, nKnots(n0), type="h", col=c0)
axis(1, at=n0, line=-2, col.ticks=c0, col=NA, col.axis=c0)
axis(4, at=.nknots.smspl(10000), line=-.5, col=c..,col.axis=c.., las=1)
```

```{r}
# an artificial example
y18 <- c(1:3, 5, 4, 7:3, 2*(2:5), rep(10, 4))
xx  <- seq(1, length(y18), len = 201)
(s2  <- smooth.spline(y18)) # GCV
(s02  <- smooth.spline(y18, spar = 0.2))
(s02. <- smooth.spline(y18, spar = 0.2, cv = NA))
plot(y18, main = deparse(s2$call), col.main = 2)
lines(s2, col = "gray"); lines(predict(s2, xx), col = 2)
lines(predict(s02, xx), col = 3); mtext(deparse(s02$call), col = 3)
```

```{r}
# show the problematic behavior of 'spar' searching, both do quite similarly (Df = 8.5 +- 0.2)
(s2  <- smooth.spline(y18, control = list(trace = TRUE, tol = 1e-6, low = -1.5)))
(s2m <- smooth.spline(y18, cv = TRUE, control = list(trace = TRUE, tol = 1e-6, low = -1.5)))
```

# splines 2

```{r}
op <- par(mfrow = c(2,1), mgp = c(2,.8,0), mar = 0.1+c(3,3,3,1))
n <- 9
x <- 1:n
y <- rnorm(n)
plot(x, y, main = paste("spline[fun](.) through", n, "points"))
lines(spline(x, y))
lines(spline(x, y, n = 201), col = 2)
```

```{r, warning=FALSE}
y <- (x-6)^2
plot(x, y, main = "spline(.) -- 3 methods")
lines(spline(x, y, n = 201), col = 2)
lines(spline(x, y, n = 201, method = "natural"), col = 3)
lines(spline(x, y, n = 201, method = "periodic"), col = 4)
legend(6, 25, c("fmm","natural","periodic"), col = 2:4, lty = 1)
```

```{r}
y <- sin((x-0.5)*pi)
f <- splinefun(x, y)
ls(envir = environment(f))
splinecoef <- get("z", envir = environment(f))
curve(f(x), 1, 10, col = "green", lwd = 1.5)
points(splinecoef, col = "purple", cex = 2)
curve(f(x, deriv = 1), 1, 10, col = 2, lwd = 1.5)
curve(f(x, deriv = 2), 1, 10, col = 2, lwd = 1.5, n = 401)
curve(f(x, deriv = 3), 1, 10, col = 2, lwd = 1.5, n = 401)
par(op)
```

```{r}
# manual spline evaluation
.x <- splinecoef$x
u <- seq(3, 6, by = 0.25)
(ii <- findInterval(u, .x))
dx <- u - .x[ii]
f.u <- with(splinecoef, y[ii] + dx*(b[ii] + dx*(c[ii] + dx* d[ii])))
stopifnot(all.equal(f(u), f.u))
```

```{r, warning=FALSE}
# an example with ties (non-unique x values)
set.seed(1)
x <- round(rnorm(30), 1); y <- sin(pi * x) + rnorm(30)/10
plot(x, y, main = "spline(x,y)  when x has ties")
lines(spline(x, y, n = 201), col = 2)
```

```{r}
# visualizes the non-unique ones
tx <- table(x)
mx <- as.numeric(names(tx[tx > 1]))
ry <- matrix(unlist(tapply(y, match(x, mx), range, simplify = FALSE)), ncol = 2, byrow = TRUE)
```

```{r}
plot(c(mx, mx), c(ry[, 1], ry[, 2]), xlab = "mx", ylab = "ry")
segments(mx, ry[, 1], mx, ry[, 2], col = "blue", lwd = 2)
```

```{r}
# an example of monotone interpolation
n <- 20
set.seed(11)
x. <- sort(runif(n)) ; y. <- cumsum(abs(rnorm(n)))
plot(x., y.)
curve(splinefun(x., y.)(x), add = TRUE, col = 2, n = 1001)
curve(splinefun(x., y., method = "monoH.FC")(x), add = TRUE, col = 3, n = 1001)
curve(splinefun(x., y., method = "hyman")   (x), add = TRUE, col = 4, n = 1001)
legend("topleft",
       paste0("splinefun( \"", c("fmm", "monoH.FC", "hyman"), "\" )"),
       col = 2:4, lty = 1, bty = "n")
```

```{r}
x. <- c(7.09, 8.09, 8.19, 8.7, 9.2, 10, 12, 15, 20)
f <- c(0, 2.76429e-5, 4.37498e-2, 0.169183, 0.469428, 0.943740,
       0.998636, 0.999919, 0.999994)
s0 <- splinefun(x., f)
s1 <- splinefun(x., f, method = "monoH.FC")
s2 <- splinefun(x., f, method = "hyman")
plot(x., f, ylim = c(-0.2, 1.2))
curve(s0(x), add = TRUE, col = 2, n = 1001) -> m0
curve(s1(x), add = TRUE, col = 3, n = 1001)
curve(s2(x), add = TRUE, col = 4, n = 1001)
legend("right",
       paste0("splinefun( \"", c("fmm", "monoH.FC", "hyman"), "\" )"),
       col = 2:4, lty = 1, bty = "n")
```

```{r}
# they seem identical, but are not quite
xx <- m0$x
plot(xx, s1(xx) - s2(xx), type = "l",  col = 2, lwd = 2,
     main = "Difference   monoH.FC - hyman"); abline(h = 0, lty = 3)
```

```{r}
x <- xx[xx < 10.2]
ccol <- adjustcolor(2:4, 0.8)
matplot(x, cbind(s0(x, deriv = 2), s1(x, deriv = 2), s2(x, deriv = 2))^2,
        lwd = 2, col = ccol, type = "l", ylab = quote({{f*second}(x)}^2),
        main = expression({{f*second}(x)}^2 ~" for the three 'splines'"))
legend("topright",
       paste0("splinefun( \"", c("fmm", "monoH.FC", "hyman"), "\" )"),
       lwd = 2, col  =  ccol, lty = 1:3, bty = "n")
```
